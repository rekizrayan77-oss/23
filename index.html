<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<title>Fus√©e Spatiale Ultimate ‚Äî Final</title>
<style>
  :root{--w:600px;--h:800px}
  body{margin:0;height:100vh;display:flex;justify-content:center;align-items:center;background:linear-gradient(180deg,#000428,#004e92);font-family:Arial,Helvetica,sans-serif;color:#fff}
  #container{position:relative;width:var(--w);height:var(--h);box-shadow:0 8px 40px rgba(0,0,0,.6);border-radius:8px;overflow:hidden}
  canvas{display:block;background:radial-gradient(circle,#001a33,#000);width:100%;height:100%}
  #ui{position:absolute;inset:0;pointer-events:none}
  #screen{position:absolute;inset:0;background:rgba(0,0,0,.72);z-index:50;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;pointer-events:auto}
  button{padding:10px 18px;border-radius:999px;border:none;background:linear-gradient(135deg,#667eea,#764ba2);color:white;font-weight:700;cursor:pointer}
  input{padding:8px 12px;border-radius:8px;border:2px solid #00d4ff;background:rgba(255,255,255,.06);color:white}
  #hud{position:absolute;top:10px;left:10px;z-index:60;font-size:15px;pointer-events:none}
  #pauseBtn{position:absolute;top:10px;right:10px;z-index:60;display:none;pointer-events:auto}
  .small{font-size:13px;opacity:.95}
  .podium{background:rgba(255,255,255,.08);padding:12px;border-radius:10px;color:#001}
  .confettiCanvas{position:absolute;left:0;top:0;z-index:45;pointer-events:none}
</style>
</head>
<body>
  <div id="container">
    <canvas id="game" width="600" height="800"></canvas>
    <canvas id="confetti" class="confettiCanvas" width="600" height="800"></canvas>

    <div id="hud">
      <div id="scoreLabel">Score: <strong id="score">0</strong></div>
      <div id="iaScores" class="small"></div>
    </div>

    <button id="pauseBtn">‚è∏ Pause</button>

    <div id="screen">
      <h1 style="margin:0;font-size:34px">üöÄ Fus√©e Spatiale üöÄ</h1>
      <div id="menuMain">
        <div class="small">Entrez votre pseudo</div>
        <input id="pseudoInput" maxlength="12" value="Joueur" />
        <div style="margin-top:8px">
          <button id="startSolo">Solo</button>
          <button id="startMulti">Multijoueur</button>
        </div>
      </div>
      <div id="multiOptions" style="display:none">
        <div class="small">Choisir difficult√© IA</div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="easyBtn">Facile</button>
          <button id="medBtn">Moyen</button>
          <button id="hardBtn">Difficile</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* ================= CONFIG ================= */
const W = 600, H = 800;
const BONUS_INTERVAL_POINTS = 110; // spacing 110 (100,210,...)
const FIRST_BONUS_AT = 100;
const BONUS_DURATION_MS = 15000; // 15s
const WIN_SCORE = 5000;

/* ================ DOM & CONTEXT ================ */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const confettiCanvas = document.getElementById('confetti');
const cctx = confettiCanvas.getContext('2d');
const screen = document.getElementById('screen');
const pauseBtn = document.getElementById('pauseBtn');
const scoreEl = document.getElementById('score');
const iaScoresEl = document.getElementById('iaScores');
const pseudoInput = document.getElementById('pseudoInput');
const startSolo = document.getElementById('startSolo');
const startMulti = document.getElementById('startMulti');
const multiOptions = document.getElementById('multiOptions');
const menuMain = document.getElementById('menuMain');
const easyBtn = document.getElementById('easyBtn');
const medBtn = document.getElementById('medBtn');
const hardBtn = document.getElementById('hardBtn');

let pseudo = 'Joueur';
let mode = 'solo';
let difficulty = 'easy';

/* ================ STATE ================ */
let keys = {};
let particles = [];
let bullets = [];
let asteroids = [];
let bonuses = [];
let iaPlayers = [];
let score = 0;
let bestSolo = 0;
let gameRunning = false;
let gamePaused = false;
let asteroidTimer = 0;
let asteroidInterval = 60;
let nextBonusThreshold = FIRST_BONUS_AT;
let celebration = false;

/* ================ PLAYER ================ */
let player = { x: 280, y: 740, w: 40, h: 60, shield:false, laser:false, bonusTimers:{} };

/* ================ HELPERS ================ */
function now(){ return Date.now(); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function rand(min,max){ return min + Math.random()*(max-min); }

/* ================ INPUT ================ */
document.addEventListener('keydown', (e)=>{ keys[e.code]=true; if(e.code==='KeyP') togglePause(); });
document.addEventListener('keyup', (e)=>{ keys[e.code]=false; });

pauseBtn.addEventListener('click', ()=> togglePause());
startSolo.addEventListener('click', ()=> { pseudo = (pseudoInput.value.trim()||'Joueur'); mode='solo'; startGame(); });
startMulti.addEventListener('click', ()=> { menuMain.style.display='none'; multiOptions.style.display='block'; });
easyBtn.addEventListener('click', ()=> { pseudo = (pseudoInput.value.trim()||'Joueur'); mode='multi'; difficulty='easy'; startGame(); });
medBtn.addEventListener('click', ()=> { pseudo = (pseudoInput.value.trim()||'Joueur'); mode='multi'; difficulty='medium'; startGame(); });
hardBtn.addEventListener('click', ()=> { pseudo = (pseudoInput.value.trim()||'Joueur'); mode='multi'; difficulty='hard'; startGame(); });

/* ================ PARTICLES ================ */
function spawnParticles(x,y,color,size,count,spread=3,life=30){
  for(let i=0;i<count;i++){
    particles.push({
      x, y,
      dx: (Math.random()*2-1)*spread,
      dy: (Math.random()*2-1)*spread,
      size: size*(0.6+Math.random()*0.8),
      life: life*(0.7+Math.random()*0.8),
      color
    });
  }
}
function drawParticles(){
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.dx; p.y += p.dy; p.life--;
    ctx.globalAlpha = Math.max(0, p.life/40);
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    if(p.life <= 0) particles.splice(i,1);
  }
}

/* ================ BULLETS (laser as ball) ================ */
function fireBullet(shooter){
  if(!shooter) return;
  if(shooter._fireUntil && now() < shooter._fireUntil) return;
  // require shooter to have laser if not score bonus?
  if(shooter !== player && !shooter.laser) {
    // IA may still shoot occasionally even without bonus? keep to only when laser active.
    return;
  }
  if(shooter === player && !player.laser) { /* player can only shoot if laser bonus active */ return; }
  shooter._fireUntil = now() + 120; // small cooldown
  bullets.push({
    x: shooter.x + shooter.w/2,
    y: shooter.y,
    vy: -14,
    r: 6,
    owner: shooter
  });
  spawnParticles(shooter.x + shooter.w/2, shooter.y - 6, '#ffb3b3', 2, 6, 1.6, 16);
}
function updateBullets(){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.y += b.vy;
    // draw bullet
    ctx.beginPath();
    ctx.fillStyle = '#ff3333';
    ctx.globalAlpha = 0.95;
    ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    spawnParticles(b.x, b.y+2, '#ff8c00', 1, 1, 0.6, 10);

    // collide with asteroids (circle-rect)
    let hitIndex = -1;
    for(let j=asteroids.length-1;j>=0;j--){
      const a = asteroids[j];
      const cx = clamp(b.x, a.x, a.x + a.w);
      const cy = clamp(b.y, a.y, a.y + a.h);
      const dx = b.x - cx, dy = b.y - cy;
      if(dx*dx + dy*dy <= b.r*b.r){
        hitIndex = j; break;
      }
    }
    if(hitIndex !== -1){
      const a = asteroids[hitIndex];
      explodeAt(a.x + a.w/2, a.y + a.h/2, 40);
      // award shooter
      if(b.owner === player) score += 10;
      else b.owner.score = (b.owner.score||0) + 10;
      asteroids.splice(hitIndex,1);
      bullets.splice(i,1);
      continue;
    }

    if(b.y < -30) bullets.splice(i,1);
  }
}

/* ================ ASTEROIDS ================ */
function spawnAsteroid(){
  const s = 18 + Math.random()*38;
  asteroids.push({
    x: Math.random()*(W - s),
    y: -s,
    w: s, h: s,
    speed: 2 + Math.random()*2 + (score/2000)
  });
}
function processAsteroids(){
  asteroidTimer++;
  if(asteroidTimer >= asteroidInterval){
    spawnAsteroid();
    asteroidTimer = 0;
    if(asteroidInterval > 22) asteroidInterval -= 0.35;
  }
  for(let i=asteroids.length-1;i>=0;i--){
    const a = asteroids[i];
    a.y += a.speed;
    // draw
    ctx.fillStyle = '#888';
    ctx.beginPath(); ctx.arc(a.x + a.w/2, a.y + a.h/2, a.w/2, 0, Math.PI*2); ctx.fill();

    // offscreen -> remove (no score)
    if(a.y > H + 40){ asteroids.splice(i,1); continue; }

    // collision player
    if(rectIntersect(player, a)){
      if(player.shield){
        spawnParticles(a.x+a.w/2, a.y+a.h/2, '#00caff', 3, 18, 3, 40);
        asteroids.splice(i,1);
      } else {
        endGame(false);
        return;
      }
    }
    // collision IA
    for(const ai of iaPlayers){
      if(!ai.alive) continue;
      if(rectIntersect(ai, a)){
        if(ai.shield){
          spawnParticles(a.x+a.w/2, a.y+a.h/2, '#00caff', 3, 12, 3, 40);
          asteroids.splice(i,1);
        } else {
          ai.alive = false;
        }
      }
    }
  }
}

/* ================ BONUSES ================ */
function spawnBonus(){
  const types = ['shield','laser','score'];
  const type = types[Math.floor(Math.random()*types.length)];
  const size = 30;
  const icon = type === 'shield' ? 'üõ°Ô∏è' : (type === 'laser' ? 'üî´' : 'üèÜ');
  bonuses.push({ x: Math.random()*(W-size), y: -size, w: size, h: size, speed: 2.6, type, icon });
}
function processBonusesSpawn(){
  if(score >= nextBonusThreshold){
    spawnBonus();
    nextBonusThreshold += BONUS_INTERVAL_POINTS;
  }
}
function drawBonuses(){
  for(let i=bonuses.length-1;i>=0;i--){
    const b = bonuses[i];
    b.y += b.speed;
    ctx.font = '24px serif';
    ctx.fillText(b.icon, b.x + 6, b.y + b.h - 6);
    // pickup player
    if(rectIntersect(player, b)){
      applyBonus(player, b.type);
      bonuses.splice(i,1); continue;
    }
    // pickup IA
    for(const ai of iaPlayers){
      if(!ai.alive) continue;
      if(rectIntersect(ai,b)){
        applyBonus(ai, b.type);
        bonuses.splice(i,1); break;
      }
    }
    if(b.y > H + 40) bonuses.splice(i,1);
  }
}
function applyBonus(entity, type){
  entity.bonusTimers = entity.bonusTimers || {};
  entity.bonusTimers[type] = now() + BONUS_DURATION_MS;
  if(type === 'shield') entity.shield = true;
  if(type === 'laser') entity.laser = true;
  if(type === 'score'){
    if(entity === player) score += 100;
    else entity.score = (entity.score||0) + 100;
  }
  spawnParticles(entity.x + entity.w/2, entity.y + entity.h/2, type==='shield' ? '#00caff' : '#ffcc66', 3, 10, 2.5, 36);
}
function updateBonusTimers(){
  const ts = now();
  // player
  if(player.bonusTimers){
    for(const t of ['shield','laser']){
      if(player.bonusTimers[t] && ts > player.bonusTimers[t]){
        if(t === 'shield') player.shield = false;
        if(t === 'laser') player.laser = false;
        delete player.bonusTimers[t];
      }
    }
  }
  // IA
  for(const ai of iaPlayers){
    if(!ai.bonusTimers) continue;
    for(const t of ['shield','laser']){
      if(ai.bonusTimers[t] && ts > ai.bonusTimers[t]){
        if(t === 'shield') ai.shield = false;
        if(t === 'laser') ai.laser = false;
        delete ai.bonusTimers[t];
      }
    }
  }
}

/* ================ DRAW ROCKET & BONUS UI ================ */
function drawRocket(p, isPlayer){
  const ts = now();
  let rocketBlink = false, shieldBlink = false;
  if(p.bonusTimers){
    if(p.bonusTimers.laser && p.bonusTimers.laser - ts < 3000) rocketBlink = true;
    if(p.bonusTimers.shield && p.bonusTimers.shield - ts < 3000) shieldBlink = true;
  }
  // gradient
  const grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
  if(isPlayer){ grad.addColorStop(0,'#00d4ff'); grad.addColorStop(1,'#0080ff'); }
  else { grad.addColorStop(0, p.color); grad.addColorStop(1, shadeColor(p.color, -30)); }
  ctx.globalAlpha = (rocketBlink && !shieldBlink) ? 0.35 : 1;
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(p.x + p.w/2, p.y);
  ctx.lineTo(p.x + p.w*0.9, p.y + p.h*0.34);
  ctx.lineTo(p.x + p.w*0.75, p.y + p.h);
  ctx.lineTo(p.x + p.w*0.25, p.y + p.h);
  ctx.lineTo(p.x + p.w*0.1, p.y + p.h*0.34);
  ctx.closePath(); ctx.fill();
  ctx.globalAlpha = 1;
  // cockpit
  ctx.fillStyle = '#87CEEB';
  ctx.beginPath(); ctx.arc(p.x + p.w/2, p.y + p.h*0.36, p.w*0.16, 0, Math.PI*2); ctx.fill();
  // flame
  ctx.fillStyle = '#ffb347';
  ctx.beginPath();
  ctx.moveTo(p.x + p.w*0.25, p.y + p.h);
  ctx.lineTo(p.x + p.w/2, p.y + p.h + 12 + Math.random()*8);
  ctx.lineTo(p.x + p.w*0.75, p.y + p.h);
  ctx.closePath(); ctx.fill();

  // shield pulse
  if(p.shield){
    const r = Math.max(p.w,p.h)/1.2 + Math.sin(now()/120)*3;
    ctx.strokeStyle = '#00caff';
    ctx.lineWidth = 3;
    if(shieldBlink){
      if(Math.floor(now()/200)%2===0){ ctx.globalAlpha = 0.22; ctx.beginPath(); ctx.arc(p.x + p.w/2, p.y + p.h/2, r+6, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha = 1; }
    } else {
      ctx.beginPath(); ctx.arc(p.x + p.w/2, p.y + p.h/2, r, 0, Math.PI*2); ctx.stroke();
    }
  }

  // bonus bars above
  drawBonusUI(p);
}
function drawBonusUI(p){
  if(!p.bonusTimers) return;
  const baseX = p.x;
  const baseY = p.y - 6;
  const entries = [];
  if(p.bonusTimers.shield) entries.push({k:'shield', color:'#00caff'});
  if(p.bonusTimers.laser) entries.push({k:'laser', color:'#ff6666'});
  for(let i=0;i<entries.length;i++){
    const key = entries[i].k;
    const color = entries[i].color;
    const remMs = Math.max(0, p.bonusTimers[key] - now());
    const rem = remMs / 1000;
    const ratio = clamp(rem / (BONUS_DURATION_MS/1000), 0, 1);
    // bg
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(baseX, baseY - (i*14) - 8, p.w, 8);
    // fg
    let alpha = 1;
    if(rem < 3) alpha = (Math.floor(now()/200)%2===0)?0.28:1;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.fillRect(baseX, baseY - (i*14) - 8, p.w * ratio, 8);
    ctx.globalAlpha = 1;
    // text
    ctx.fillStyle = '#fff';
    ctx.font = '11px Arial';
    const label = key === 'shield' ? 'üõ°' : 'üî´';
    ctx.fillText(`${label} ${rem.toFixed(1)}s`, baseX, baseY - (i*14) - 12);
  }
}

/* color shading helper */
function shadeColor(hex, percent){
  const num = parseInt(hex.slice(1),16);
  let r = (num >> 16) + percent; r = clamp(r,0,255);
  let g = ((num >> 8) & 0x00FF) + percent; g = clamp(g,0,255);
  let b = (num & 0x0000FF) + percent; b = clamp(b,0,255);
  return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
}

/* ================ IA LOGIC ================ */
function initIA(){
  const colors = ['#ff6b6b','#ffd93d','#6bcf7f','#a29bfe'];
  const names = ['Astro','Nova','Cosmos','Stellar'];
  iaPlayers = [];
  for(let i=0;i<4;i++){
    iaPlayers.push({
      x: 60 + i*120,
      y: 740,
      w: 40, h: 60,
      color: colors[i],
      name: names[i],
      alive: true,
      shield:false,
      laser:false,
      bonusTimers: {},
      score: 0,
      _nextFire: 0,
      speed: (difficulty==='hard'?5:(difficulty==='medium'?4:3))
    });
  }
}
function moveIA(){
  const ts = now();
  for(const ai of iaPlayers){
    if(!ai.alive) continue;
    // parameters
    let params;
    if(difficulty==='hard') params = {evade:1.35, aggro:0.95, react:0.98};
    else if(difficulty==='medium') params = {evade:1.0, aggro:0.65, react:0.75};
    else params = {evade:0.6, aggro:0.4, react:0.6};

    let mvx = 0, mvy = 0;

    // sense nearest asteroid in front
    const nearby = asteroids.filter(a => Math.abs((a.x+a.w/2)-(ai.x+ai.w/2)) < 150 && a.y < ai.y + 150);
    if(nearby.length && Math.random() < params.react){
      const threat = nearby.reduce((best,a) => {
        const d = Math.hypot((a.x+a.w/2)-(ai.x+ai.w/2),(a.y+a.h/2)-(ai.y+ai.h/2));
        return (!best || d < best.d) ? {a,d} : best;
      }, null).a;
      mvx += (threat.x + threat.w/2 > ai.x + ai.w/2) ? -1 : 1;
      mvy += (threat.y < ai.y) ? 1 : -1;
    }

    // go for bonus if close
    const bonusesNearby = bonuses.map(b=>({b,d:Math.hypot(b.x-ai.x,b.y-ai.y)})).sort((a,b)=>a.d-b.d);
    if(bonusesNearby.length && Math.random() < params.aggro){
      const target = bonusesNearby[0].b;
      if(Math.abs(target.x - ai.x) > 6) mvx += (target.x > ai.x) ? 1 : -1;
      if(Math.abs(target.y - ai.y) > 6) mvy += (target.y > ai.y) ? 1 : -1;
    }

    // if asteroid directly ahead and ai.laser -> align & shoot
    const ahead = asteroids.find(a => Math.abs((a.x+a.w/2)-(ai.x+ai.w/2)) < 22 && a.y < ai.y && a.y > ai.y - 420);
    if(ahead && ai.laser && Math.random() < params.react){
      if(Math.abs((ai.x+ai.w/2)-(ahead.x+ahead.w/2)) < 18){
        if(ts > ai._nextFire){ fireBullet(ai); ai._nextFire = ts + 200; }
      } else {
        mvx += (ahead.x + ahead.w/2 > ai.x + ai.w/2) ? 1 : -1;
      }
    }

    // wandering
    if(Math.random() < 0.012) mvx += (Math.random()<0.5 ? -1:1);
    if(Math.random() < 0.009) mvy += (Math.random()<0.5 ? -1:1);

    // repulsion from other IA to avoid sticking
    for(const other of iaPlayers){
      if(other === ai || !other.alive) continue;
      const dx = ai.x - other.x, dy = ai.y - other.y;
      const dist = Math.hypot(dx,dy);
      if(dist < 48){
        mvx += (dx / Math.max(1, dist)) * 1.3;
        mvy += (dy / Math.max(1, dist)) * 1.3;
      }
    }

    ai.x += mvx * ai.speed * 0.6 * params.evade;
    ai.y += mvy * ai.speed * 0.45 * params.evade;
    ai.x = clamp(ai.x, 0, W - ai.w);
    ai.y = clamp(ai.y, 0, H - ai.h);

    // expire ai bonus timers here just in case
    if(ai.bonusTimers){
      for(const t of ['shield','laser']){
        if(ai.bonusTimers[t] && now() > ai.bonusTimers[t]){
          if(t==='shield') ai.shield = false;
          if(t==='laser') ai.laser = false;
          delete ai.bonusTimers[t];
        }
      }
    }
  }
}

/* ================ DRAW IA ================ */
function drawIA(){
  for(const ai of iaPlayers){
    if(!ai.alive) continue;
    drawRocket(ai, false);
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.fillText(`${ai.name} ${ai.score?(':'+ai.score):''}`, ai.x, ai.y - 28);
  }
  // update IA scoreboard
  if(mode === 'multi') iaScoresEl.textContent = iaPlayers.map(a=>`${a.name}:${a.score}`).join(' | ');
  else iaScoresEl.textContent = '';
}

/* ================ EXPLOSIONS ================ */
function explodeAt(x,y,intensity=36){
  for(let i=0;i<intensity;i++){
    const col = (Math.random() < 0.33) ? '#333' : (['#ff4500','#ff8c00','#ff6347'][Math.floor(Math.random()*3)]);
    particles.push({
      x, y,
      dx: (Math.random()*2-1)*4,
      dy: (Math.random()*2-1)*4,
      size: 2 + Math.random()*4,
      life: 24 + Math.random()*36,
      color: col
    });
  }
}

/* ================ COLLISIONS UTILS ================ */
function rectIntersect(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

/* ================ PLAYER MOVEMENT + SHOOT ================ */
function movePlayer(){
  if(keys.ArrowLeft || keys.KeyA) player.x -= 6;
  if(keys.ArrowRight || keys.KeyD) player.x += 6;
  if(keys.ArrowUp || keys.KeyW) player.y -= 4;
  if(keys.ArrowDown || keys.KeyS) player.y += 4;
  player.x = clamp(player.x, 0, W - player.w);
  player.y = clamp(player.y, 0, H - player.h);

  // player shoot
  if((keys.Space || keys.KeyK) && player.laser && (!player._nextFire || now() > player._nextFire)){
    fireBullet(player);
    player._nextFire = now() + 140;
  }
  // expire timers
  updateBonusTimers();
}

/* ================ SPAWN / DRAW LOOP HELPERS ================ */
function processSpawnsAndDraws(){
  // asteroids
  processAsteroids();

  // bonuses spawn and drawing
  processBonusesSpawn();
  drawBonuses();

  // bullets update was called earlier
}

/* ================ HUD/END ================ */
function updateHUD(){
  scoreEl.textContent = score;
  if(score >= WIN_SCORE){
    showWinnerAndCelebrate(pseudo);
  }
  for(const ai of iaPlayers){
    if(ai.score >= WIN_SCORE){
      showWinnerAndCelebrate(ai.name);
    }
  }
}

/* End game flow */
function endGame(showPodium){
  gameRunning = false;
  screen.style.display = 'flex';
  if(mode === 'solo'){
    const newRec = score > bestSolo;
    if(newRec) bestSolo = score;
    screen.innerHTML = `<h1>üèÅ Fin de partie</h1><p>Score: ${score}</p>${newRec?'<p><strong>NEW RECORD !</strong></p>':''}
      <div style="margin-top:10px"><button id="replayBtn">Rejouer</button><button id="menuBtn">Menu</button></div>`;
    document.getElementById('replayBtn').onclick = ()=>{ initGame(); screen.style.display='none'; };
    document.getElementById('menuBtn').onclick = ()=>{ showMainMenu(); };
  } else {
    // podium
    const all = iaPlayers.map(a=>({name:a.name,score:a.score,alive:a.alive})).concat([{name:pseudo,score:score,alive:true}]);
    all.sort((a,b)=>b.score-a.score);
    let html = `<div class="podium"><h2>Podium</h2><ol>`;
    for(let i=0;i<all.length;i++) html += `<li>${i+1}. ${all[i].name}: ${all[i].score} ${!all[i].alive? '(√©limin√©)' : ''}</li>`;
    html += `</ol></div><div style="margin-top:10px"><button id="menuBtn2">Menu</button><button id="replayBtn2">Rejouer</button></div>`;
    screen.innerHTML = html;
    document.getElementById('menuBtn2').onclick = ()=> showMainMenu();
    document.getElementById('replayBtn2').onclick = ()=> { initGame(); screen.style.display='none'; };
  }
}

/* Winner with celebration */
function showWinnerAndCelebrate(name){
  gameRunning = false;
  screen.style.display = 'flex';
  screen.innerHTML = `<div style="text-align:center">
    <div style="font-size:34px">üéâ F√©licitations ‚Äî ${name} ! üéâ</div>
    <div style="margin-top:10px"><button id="menuAfter">Menu</button><button id="replayAfter">Rejouer</button></div>
  </div>`;
  document.getElementById('menuAfter').onclick = ()=> showMainMenu();
  document.getElementById('replayAfter').onclick = ()=> { initGame(); screen.style.display='none'; };
  startConfetti();
}

/* ================ CONFETTI ================ */
let confetti = [];
function startConfetti(){
  confetti = [];
  for(let i=0;i<180;i++){
    confetti.push({
      x: Math.random()*W,
      y: Math.random()*-H,
      dx: (Math.random()*2-1)*2,
      dy: 2 + Math.random()*4,
      w: 4 + Math.random()*8,
      h: 6 + Math.random()*6,
      color: ['#ff5f6d','#ffc371','#8ee5a1','#9aa7ff'][Math.floor(Math.random()*4)],
      rot: Math.random()*360
    });
  }
  confettiLoop();
}
function confettiLoop(){
  cctx.clearRect(0,0,W,H);
  for(const p of confetti){
    p.x += p.dx; p.y += p.dy; p.rot += 6;
    cctx.save();
    cctx.translate(p.x,p.y);
    cctx.rotate(p.rot * Math.PI/180);
    cctx.fillStyle = p.color;
    cctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
    cctx.restore();
  }
  confetti = confetti.filter(p=>p.y < H + 60);
  if(confetti.length) requestAnimationFrame(confettiLoop);
}

/* ================ MAIN GAME LOOP ================ */
function gameLoop(){
  if(!gameRunning || gamePaused) return;
  ctx.clearRect(0,0,W,H);

  // background stars
  ctx.fillStyle = 'white';
  for(let i=0;i<40;i++){
    ctx.fillRect((i*137)%W, ((i*137 + score*2)%H), 2,2);
  }

  // update / draw
  movePlayer();
  moveIA();

  updateBullets();
  processAsteroids();

  processBonusesSpawn();
  drawBonuses();

  // draw rockets
  drawRocket(player, true);
  drawIA();

  drawParticles();

  updateHUD();

  requestAnimationFrame(gameLoop);
}

/* ================ START / INIT ================ */
function startGame(){
  // hide menus
  screen.style.display = 'none';
  menuMain.style.display = 'none';
  multiOptions.style.display = 'none';
  // reset state
  particles = []; bullets = []; asteroids = []; bonuses = []; iaPlayers = [];
  score = 0; scoreEl.textContent = score;
  player = { x: 280, y: 740, w: 40, h: 60, shield:false, laser:false, bonusTimers:{} };
  asteroidInterval = (mode==='multi' && difficulty==='hard') ? 40 : 60;
  asteroidTimer = 0;
  nextBonusThreshold = FIRST_BONUS_AT;
  celebration = false;
  // init IA if needed
  if(mode === 'multi') initIA();
  pauseBtn.style.display = 'block';
  gameRunning = true; gamePaused = false;
  requestAnimationFrame(gameLoop);
}
function initGame(){ startGame(); }

/* toggle pause with UI */
function togglePause(){
  gamePaused = !gamePaused;
  if(gamePaused){
    pauseBtn.textContent = '‚ñ∂ Reprendre';
    screen.style.display = 'flex';
    screen.innerHTML = `<h2>‚è∏ Pause</h2><div style="display:flex;gap:8px"><button id="resumeBtn">Reprendre</button><button id="menuPauseBtn">Menu</button></div>`;
    document.getElementById('resumeBtn').onclick = ()=>{ screen.style.display='none'; gamePaused = false; pauseBtn.textContent='‚è∏ Pause'; requestAnimationFrame(gameLoop); };
    document.getElementById('menuPauseBtn').onclick = ()=>{ gameRunning = false; showMainMenu(); };
  } else {
    pauseBtn.textContent = '‚è∏ Pause';
    screen.style.display = 'none';
    requestAnimationFrame(gameLoop);
  }
}

/* show main menu */
function showMainMenu(){
  screen.style.display = 'flex';
  menuMain.style.display = 'block';
  multiOptions.style.display = 'none';
  // rewire start buttons (they exist already)
}

/* ================ UTILS WRAPPERS not duplicated ================ */
/* drawBonuses already declared above */
function drawBonuses(){ // placeholder forward to earlier definition (ensures function exists in any calling order)
  for(let i=bonuses.length-1;i>=0;i--){
    const b = bonuses[i];
    b.y += b.speed;
    ctx.font = '24px serif';
    ctx.fillText(b.icon, b.x + 6, b.y + b.h - 6);
    if(rectIntersect(player,b)){ applyBonus(player,b.type); bonuses.splice(i,1); continue; }
    for(const ai of iaPlayers){ if(!ai.alive) continue; if(rectIntersect(ai,b)){ applyBonus(ai,b.type); bonuses.splice(i,1); break; } }
    if(b.y > H + 40) bonuses.splice(i,1);
  }
}

/* alias updateBullets_impl already used */
function updateBullets_impl(){ updateBullets(); }

/* ensure called wrappers used earlier are connected */
function processBonusesSpawn(){ processBonusesSpawnImpl(); }
function processBonusesSpawnImpl(){ processBonusesSpawn(); }

/* Small safe exports for console debugging */
window.__game = {
  startGame, showMainMenu, getState: ()=>({score,player,iaPlayers,asteroids,bonuses})
};

/* show main menu initially */
showMainMenu();

/* ================ END OF FILE ================ */
/* If you see any JS error in the browser console, copie-colle le message ici et je corrige imm√©diatement. */
</script>
</body>
</html>
